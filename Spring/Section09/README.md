# 섹션 9. 스코프

### 싱글톤
스프링의 기본 스코프이다.  보통은 이걸 쓴다.  
항상 같은 인스턴스의 스프링 빈을 반환함을 보장한다.  즉 싱글톤 빈을 스프링에서 관리해주다가, 요청할 때 해당 스프링 빈을 지원해주어 각 클라이언트는 사실상 같은 빈을 공유하여 사용하게 된다.  

### 프로토타입 스코프
빈의 생성과 의존관계 주입까지만 관리하고 이후에는 관리하지 않는다. 그래서 소멸자가 자동으로 불러지지 않는다. 보통은 안쓰지만, 굉장히 특수한 경우에서 사용한다.   
항상 새로운 인스턴스를 생성해서 반환한다. 요청하면 그 때 생성하고, **필요하면 의존관계 주입과 초기화까지 해서 클라이언트에게 던져주고 더이상 관리하지 않는다.**    
- 테스트를 해보면 predestroy 어노테이션을 붙여주더라도 정말 destroy가 실행되지 않는다. 직접 destroy해주어야 한다.

### 싱글톤 빈과 프로토타입 빈을 함께 사용하면 문제가 발생
둘을 자동 주입해주게 되면, 싱글톤 빈이 프로토타입 빈을 들고다녀서 새로 객체가 생성되지 않는다. 생성 시점에 주입받긴 하지만, 함께 생성되고 들려다니기 때문에 의도와 달리 계속 동일한 객체가 된다. 의도하는 바대로 코드 내에서 사용하기 위해선, application context를 매번 주입 받아야 한다.   

### 어떻게 같이 사용할까?
- DL(Dependency Lookup) : 스프링 컨테이너에서 빈을 찾아준다.
- ObjectProvider, ObjectFactory(옛날버전) : 테스트를 돌려보면 프로토타입 빈이 매번 생성된다. 항상 새로운 프로토타입 빈을 찾아주면서 생성해주고 있기 때문이다.
- 스프링 의존성이 너무 높다.

### JSR-330 Provider
- 자바 표준으로, `javax.inject:javax.inject:1` 라이브러리를 gradle에 추가하여 사용한다.
- 직전에 사용한 ObjectProvider를 그대로 대체해서 사용할 수 있고, 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다.

### 웹 관련 스코프
1. request : 고객 요청이 나갈 때 소멸된다. **각 HTTP 요청마다** 별도의 빈 인스턴스가 생성되고, 관리된다.
2. session : 세션 생성부터 소멸까지, HTTP Session과 동일한 생명주기를 가지는 스코프
3. application : 서블릿 컨텍스와 같은 범위로 유지된다.
4. websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프

사용하기 위해서는 gradle에 spring-boot-starter-web 의존성을 추가해주어야 한다.  

### request 실습에서 한 일
- 동시에 여러 http 요청이 왔을 때, 어떤 요청이 남긴 로그인지 구분하기 위한 Logger를 개발한다.
1. MyLogger : 로그를 출력해준다. request scope를 갖고, uuid와 requestURL과 message를 찍어주는 log 메서드를 가진다.
2. LogDemoController : 로거가 잘 작동하는지 확인하는 테스트용 컨트롤러. HttpServletRequest를 통해서  `http://localhost:8080/log-demo`  이라는 requestURL을 받으면, 이 URL을 저장해두고 controller test라는 메세지를 log에 넘겨준다.
3. LogDemoService : 비즈니스 로직이 있는 서비스 계층에서 로그를 출력해보기 위한다. 단, 서비스 계층은 웹 기술에 종속되지 않도록 순수한 자바 코드로 작성하는 것이 좋다.

### Provider까지 줄이기 : 스코프와 프록시
가짜 프록시 객체를 생성해서 MyLogger 대신에 등록되어 작동한다. 의존관계 주입도 이 가짜 프록시 객체가 주입되고, 프록시 객체가 myLogger를 호출하게 된다. 이를 통해 request scope를 마치 싱글톤 빈을 사용하듯이 쓸 수 있다. (하지만 싱글톤은 아니고, 매 요청마다 새로 생기기 때문에 주의해서 사용해야 한다.)  
왜 이렇게 하는걸까? 진짜 요청이 들어올 때까지 진짜 객체 조회를 지연하는 것이다.